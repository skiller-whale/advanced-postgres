#! /usr/bin/env python3

import requests
import threading
import os
import psycopg2
import psycopg2.extras
import json
import hashlib
import time
from urllib.parse import urljoin


WATCHED_EXTS = [".sh", ".sql"]
IGNORE_DIRS = [".git"]

SERVER_URL = os.getenv('SERVER_URL', "https://train.skillerwhale.com")


def run_sync(attendance_id):
    file_uploader = FileUploader(attendance_id)
    pinger = Pinger(attendance_id)
    watcher = Watcher(file_uploader, base_path="src")
    watcher.poll_for_changes(loop_callback=pinger.ping)


def pg_update():
    pg_executor = PgExec(os.environ.get("PSYCOPG_CONNECTION_STRING"))
    watcher = Watcher(pg_executor, base_path="src")
    watcher.poll_for_changes()


def skiller_whale_sync():
    print("  _____ _    _ _ _            __          ___           _      ")
    print(" / ____| |  (_) | |           \\ \\        / / |         | |     ")
    print("| (___ | | ___| | | ___ _ __   \\ \\  /\\  / /| |__   __ _| | ___ ")
    print(" \\___ \\| |/ / | | |/ _ \\ '__|   \\ \\/  \\/ / | '_ \\ / _` | |/ _ \\")
    print(" ____) |   <| | | |  __/ |       \\  /\\  /  | | | | (_| | |  __/")
    print("|_____/|_|\\_\\_|_|_|\\___|_|        \\/  \\/   |_| |_|\\__,_|_|\\___| ")
    print("")
    attendance_id = os.environ.get("ATTENDANCE_ID")
    print("")
    print(f'We\'re going to start watching this directory for changes so that the trainer can see your progress, using id {attendance_id}')

    sync_thread = threading.Thread(target=run_sync, args=[attendance_id])
    sync_thread.start()

    pg_update()


class PgExec:
    RETRY_TIME = 2

    def __init__(self, connection_string):
        self.connection_string = connection_string
        print(connection_string)
        self._connection = None

    @property
    def connection(self):
        if self._connection is None:
            self._connection = self._get_connection()
        return self._connection

    def _get_connection(self):
        while True:
            try:
                return psycopg2.connect(self.connection_string)
            except psycopg2.OperationalError:
                print(f"Could not find the database, retrying in {self.RETRY_TIME}s")
                time.sleep(self.RETRY_TIME)

    def execute_sql(self, sql):
        with self.connection.cursor(cursor_factory=psycopg2.extras.RealDictCursor) as cursor:
            cursor.execute(sql)
            return cursor.fetchall()

    def file_changed(self, path):
        print("")
        print(f'RUNNING FILE {path}')
        print("")
        with open(path, "r") as f:
            contents = f.read()

        try:
            query_results = self.execute_sql(contents)
        except psycopg2.Error as err:
            self.connection.rollback()
            print("POSTGRES ERROR:", err)
        else:
            for result in query_results:
                print("--- ROW ---")
                for key in result:
                    print(str(key).upper() + ": " + str(result[key]))
                print("")


def create_skiller_whale_url(path):
    return urljoin(SERVER_URL, path)


class FileUploader:
    def __init__(self, attendance_id):
        self.attendance_id = attendance_id

    @property
    def uri(self):
        return create_skiller_whale_url(self.path)

    @property
    def path(self):
        return f'attendances/{self.attendance_id}/file_snapshots'

    @staticmethod
    def get_file_data(path):
        with open(path, "r") as f:
            data ={"relative_path": path, "contents": f.read()}
            return json.dumps(data)

    @staticmethod
    def get_headers(data):
        return {
            "Content-Type": "application/json",
            "Content-Length": str(len(data))
        }

    def post_file(self, path):
        data = self.get_file_data(path)
        headers = self.get_headers(data)
        return requests.post(self.uri, data=data, headers=headers)

    def file_changed(self, path):
        print(f"Uploading: {path}", end='\t')
        if not self.attendance_id:
            print("No attendance id set; file update not sent.")
            return

        response = self.post_file(path)
        print(f"Status: {response.status_code}")

        if response.text:
            print(response.text)


class Pinger:
    def __init__(self, attendance_id):
        self.attendance_id = attendance_id

    @property
    def uri(self):
        return create_skiller_whale_url(self.path)

    @property
    def path(self):
        return f'attendances/{self.attendance_id}/pings'

    def ping(self):
        requests.post(self.uri)


class Watcher:
    def __init__(self, responder, base_path='.'):
        self.responder = responder
        self.base_path = base_path
        self._file_hashes = {}
        # Tracks whether this is the first pass of the directory tree. If not,
        # then any new file encountered will be treated as an update.
        self._first_pass = True

    @staticmethod
    def get_file_hash(path):
        """Return a hash digest of the file located at path"""
        with open(path, "rb") as f:
            contents = f.read()
            return hashlib.md5(contents).hexdigest()

    def _respond_to_file_change(self, path):
        _, extension = os.path.splitext(path)
        if extension not in WATCHED_EXTS:
            return

        hashed = self.get_file_hash(path)
        if not self._first_pass:
            old_hash = self._file_hashes.get(path)
            if old_hash != hashed:
                self.responder.file_changed(path)
        self._file_hashes[path] = hashed

    def _check_dir_for_changes(self, dir_path):
        if os.path.basename(dir_path) in IGNORE_DIRS:
            return

        for filename in os.listdir(dir_path):
            new_path = os.path.join(dir_path, filename)
            if os.path.isdir(new_path):
                # Recursively check subdirectories
                self._check_dir_for_changes(new_path)
            else:
                self._respond_to_file_change(new_path)

    def poll_for_changes(self, wait_time=1, loop_callback=lambda: None):
        """Optionally specify loop_callback, which is called each iteration"""
        while True:
            loop_callback()
            self._check_dir_for_changes(self.base_path)
            self._first_pass = False
            time.sleep(wait_time)  # Poll for changes every `wait_time` seconds


if __name__ == "__main__":
    skiller_whale_sync()
